# -*- coding: utf-8 -*-
"""Copia de A01571442_ProyectoStreamlitencolab2 (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EgdiCepRarsud74hZlaPplkshs5psojE
"""

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px


# Definir la paleta verde como diccionario
color_palettes = {
    "Verde": {
        "button_color": "#66BB6A",  # Botones verdes
        "sidebar_bg_color": "#A5D6A7",  # Sidebar verde claro
        "main_bg_color": "#069910",  # Fondo verde claro
        "text_color": "white",  # Texto blanco
        "top_bar_color": "#388E3C"  # Barra superior verde
    }
}

# Cargar el archivo de estilos CSS
with open("/content/styles.css") as css_file:
    st.markdown(f"<style>{css_file.read()}</style>", unsafe_allow_html=True)

# Seleccionar paleta verde
selected_palette = color_palettes["Verde"]

# Aplicar paleta de colores desde CSS
st.markdown(
    f"""
    <style>
    :root {{
        --top-bar-color: {selected_palette["top_bar_color"]};
        --sidebar-bg-color: {selected_palette["sidebar_bg_color"]};
        --main-bg-color: {selected_palette["main_bg_color"]};
        --button-color: {selected_palette["button_color"]};
        --text-color: {selected_palette["text_color"]};
    }}
    </style>
    """,
    unsafe_allow_html=True
)


@st.cache_data
def load_data():

    df = pd.read_excel('/content/FIFA_data_jesus_.csv.xlsx')
    df = df.dropna()
    return df

try:
    df = load_data()
    st.badge(f"‚úÖ Datos cargados: {len(df)} registros", icon=":material/check:", color="green")
except Exception as e:
    st.error(f"Error al cargar los datos: {e}")
    st.stop()

st.title('FIFA Analysis')

st.subheader("Original DataFrame:")
st.dataframe(df.head())


# T√≠tulo principal
st.title("üìä Dashboard de An√°lisis de Overall - FIFA")

st.header("‚öΩ M√©tricas Principales")
met_col1, met_col2, met_col3, met_col4 = st.columns(4)

with met_col1:
  avg_overall = df['Overall'].mean()
  st.metric("‚≠ê Promedio Overall", f"{avg_overall:.2f}")

with met_col2:
    avg_potential = df['Potential'].mean()
    st.metric("üß† Promedio Potential", f"{avg_potential:.2f}")

with met_col3:
    avg_value = df['Value'].mean()
    st.metric("üí∞ Valor Promedio (‚Ç¨)", f"‚Ç¨{avg_value:,.0f}")

with met_col4:
    most_valuable = df.loc[df['Value'].idxmax()]
    st.metric("üèÜ Jugador M√°s Valioso", f"{most_valuable['Name']}", f"‚Ç¨{most_valuable['Value']:,.0f}")

st.markdown("---")

tab1, tab2, tab3, tab4 = st.tabs([
    "üìà Evoluci√≥n de Potencial",
    "üåç An√°lisis Geogr√°fico",
    "üèÖ An√°lisis de Jugadores",
    "üíº An√°lisis de Segmentos"
])


#GRAFICA1
with tab1:
    st.subheader("Evoluci√≥n de Potencial por Contrato Valido")

    metric_map = {"Potential": "Potential", "Overall": "Overall"}
    time_map = {"Age": "Age", "A√±o de Contrato": "Contract Valid Year"}

    gra1_col1, gra1_col2 = st.columns(2)
    with gra1_col1:
        time_grouping = st.selectbox("Agrupar por", ["Age"])
    with gra1_col2:
        metric_type = st.selectbox("Metrica", ["Potential", "Overall"])

    selected_metric = metric_map[metric_type]
    selected_time = time_map[time_grouping]

    df_time = df.groupby(selected_time).agg({'Overall': 'mean', 'Potential': 'mean'}).reset_index()

    fig_time = px.line(
        df_time,
        x=selected_time,
        y=selected_metric,
        title=f"Evoluci√≥n de {metric_type} por {time_grouping}",
        markers=True
    )
    fig_time.update_traces(line_color='#1f77b4', line_width=3)
    fig_time.update_layout(hovermode='x unified')

    if time_grouping == "A√±o de Contrato":
        fig_time.update_xaxes(dtick="M12", tickformat="%Y")

    st.plotly_chart(fig_time, use_container_width=True)


#GRAFICA2
with tab2:
    st.subheader("üåç An√°lisis por Nacionalidad y M√©trica Ponderada")

    geo_col1, geo_col2 = st.columns(2)
    with geo_col1:
        geo_level = st.selectbox("Nivel Geogr√°fico", ["Nationality", "Club"])
    with geo_col2:
        geo_metric = st.selectbox("Selecciona la M√©trica", ["Value", "Overall", "Potential"])

    df_geo = (
        df.groupby(geo_level)
        .agg(
            total_value=(geo_metric, 'sum'),
            avg_value=(geo_metric, 'mean'),
            count_players=('Name', 'count')
        )
        .assign(weighted_score=lambda x: x['avg_value'] * (x['count_players'] / x['count_players'].max()))
        .reset_index()
        .sort_values("weighted_score", ascending=False)
        .head(20)
    )

    fig_geo = px.bar(
        df_geo,
        x=geo_level,
        y="weighted_score",
        title=f"Top 20 {geo_level} por Puntaje Ponderado de {geo_metric}",
        color="weighted_score",
        color_continuous_scale='Viridis'
    )
    fig_geo.update_layout(
        xaxis_tickangle=-45,
        yaxis_title="Puntaje Ponderado",
        xaxis_title=geo_level
    )
    st.plotly_chart(fig_geo, use_container_width=True)


#GRAFICA3
with tab3:
    st.subheader("üèÖ An√°lisis de Jugadores")

    gra2_col1, gra2_col2 = st.columns(2)
    with gra2_col1:
        top_n_players = st.slider("Selecciona el Top N de jugadores a mostrar", 5, 30, 15)
    with gra2_col2:
        player_metric = st.selectbox("Ordenar por", ["Value", "Wage", "Overall", "Potential"])

    for col in ["Value", "Wage"]:
        if df[col].dtype == 'object':
            df[col] = (
                df[col]
                .astype(str)
                .str.replace('‚Ç¨', '', regex=False)
                .str.replace('M', 'e6', regex=False)
                .str.replace('K', 'e3', regex=False)
                .apply(pd.eval)
            )

    df["Overall"] = pd.to_numeric(df["Overall"], errors='coerce')
    df["Potential"] = pd.to_numeric(df["Potential"], errors='coerce')

    df_players = (
        df.groupby('Name')
        .agg({
            'Value': 'mean',
            'Wage': 'mean',
            'Overall': 'mean',
            'Potential': 'mean'
        })
        .reset_index()
        .sort_values(player_metric, ascending=False)
        .head(top_n_players)
    )

    fig_players = px.bar(
        df_players,
        y='Name',
        x=player_metric,
        orientation='h',
        title=f"Top {top_n_players} Jugadores por {player_metric}",
        color=player_metric,
        color_continuous_scale='Sunset'
    )
    fig_players.update_layout(
        yaxis={'categoryorder': 'total ascending'},
        xaxis_title=player_metric,
        yaxis_title="Jugador"
    )
    st.plotly_chart(fig_players, use_container_width=True)


#GRAFICA4
with tab4:
    st.subheader("üíº An√°lisis de Segmentos (Club o Nacionalidad)")

    segment_level = st.selectbox("Selecciona el tipo de segmento:", ["Club", "Nationality"])
    df_segment = (
        df.groupby(segment_level)
        .agg({
            "Value": "sum",
            "Wage": "sum",
            "Overall": "mean",
            "Potential": "mean",
            "Name": "count"
        })
        .reset_index()
        .rename(columns={"Name": "CountPlayers"})
        .sort_values("Value", ascending=False)
        .head(15)
    )

    gra3_col1, gra3_col2 = st.columns(2)
    with gra3_col1:
        fig_seg_value = px.pie(
            df_segment,
            values="Value",
            names=segment_level,
            title=f"Distribuci√≥n del Valor Total por {segment_level}",
            hole=0.4,
            color_discrete_sequence=px.colors.sequential.RdBu
        )
        st.plotly_chart(fig_seg_value, use_container_width=True)

    with gra3_col2:
        fig_seg_overall = px.pie(
            df_segment,
            values="Overall",
            names=segment_level,
            title=f"Promedio de Overall por {segment_level}",
            hole=0.4,
            color_discrete_sequence=px.colors.sequential.Viridis
        )
        st.plotly_chart(fig_seg_overall, use_container_width=True)